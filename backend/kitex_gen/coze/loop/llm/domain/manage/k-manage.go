// Code generated by Kitex v0.13.1. DO NOT EDIT.

package manage

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/cloudwego/gopkg/protocol/thrift"
	kutils "github.com/cloudwego/kitex/pkg/utils"

	"github.com/coze-dev/cozeloop/backend/kitex_gen/coze/loop/llm/domain/common"
)

var (
	_ = common.KitexUnusedProtection
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.STOP
)

func (p *Model) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Model[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *Model) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ModelID = _field
	return offset, nil
}

func (p *Model) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.WorkspaceID = _field
	return offset, nil
}

func (p *Model) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *Model) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Desc = _field
	return offset, nil
}

func (p *Model) FastReadField5(buf []byte) (int, error) {
	offset := 0
	_field := NewAbility()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Ability = _field
	return offset, nil
}

func (p *Model) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *Protocol
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Protocol = _field
	return offset, nil
}

func (p *Model) FastReadField7(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfig()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfig = _field
	return offset, nil
}

func (p *Model) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[common.Scenario]*ScenarioConfig, size)
	values := make([]ScenarioConfig, size)
	for i := 0; i < size; i++ {
		var _key common.Scenario
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		_val := &values[i]
		_val.InitDefault()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field[_key] = _val
	}
	p.ScenarioConfigs = _field
	return offset, nil
}

func (p *Model) FastReadField9(buf []byte) (int, error) {
	offset := 0
	_field := NewParamConfig()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ParamConfig = _field
	return offset, nil
}

func (p *Model) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Model) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField9(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Model) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Model) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetModelID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.ModelID)
	}
	return offset
}

func (p *Model) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetWorkspaceID() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.WorkspaceID)
	}
	return offset
}

func (p *Model) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *Model) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDesc() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Desc)
	}
	return offset
}

func (p *Model) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAbility() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 5)
		offset += p.Ability.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Model) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocol() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Protocol)
	}
	return offset
}

func (p *Model) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfig() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 7)
		offset += p.ProtocolConfig.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Model) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetScenarioConfigs() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 8)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.ScenarioConfigs {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, k)
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRUCT, length)
	}
	return offset
}

func (p *Model) fastWriteField9(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetParamConfig() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 9)
		offset += p.ParamConfig.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Model) field1Length() int {
	l := 0
	if p.IsSetModelID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Model) field2Length() int {
	l := 0
	if p.IsSetWorkspaceID() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Model) field3Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *Model) field4Length() int {
	l := 0
	if p.IsSetDesc() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Desc)
	}
	return l
}

func (p *Model) field5Length() int {
	l := 0
	if p.IsSetAbility() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Ability.BLength()
	}
	return l
}

func (p *Model) field6Length() int {
	l := 0
	if p.IsSetProtocol() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Protocol)
	}
	return l
}

func (p *Model) field7Length() int {
	l := 0
	if p.IsSetProtocolConfig() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfig.BLength()
	}
	return l
}

func (p *Model) field8Length() int {
	l := 0
	if p.IsSetScenarioConfigs() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.ScenarioConfigs {
			_, _ = k, v

			l += thrift.Binary.StringLengthNocopy(k)
			l += v.BLength()
		}
	}
	return l
}

func (p *Model) field9Length() int {
	l := 0
	if p.IsSetParamConfig() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ParamConfig.BLength()
	}
	return l
}

func (p *Model) DeepCopy(s interface{}) error {
	src, ok := s.(*Model)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ModelID != nil {
		tmp := *src.ModelID
		p.ModelID = &tmp
	}

	if src.WorkspaceID != nil {
		tmp := *src.WorkspaceID
		p.WorkspaceID = &tmp
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Desc != nil {
		var tmp string
		if *src.Desc != "" {
			tmp = kutils.StringDeepCopy(*src.Desc)
		}
		p.Desc = &tmp
	}

	var _ability *Ability
	if src.Ability != nil {
		_ability = &Ability{}
		if err := _ability.DeepCopy(src.Ability); err != nil {
			return err
		}
	}
	p.Ability = _ability

	if src.Protocol != nil {
		tmp := *src.Protocol
		p.Protocol = &tmp
	}

	var _protocolConfig *ProtocolConfig
	if src.ProtocolConfig != nil {
		_protocolConfig = &ProtocolConfig{}
		if err := _protocolConfig.DeepCopy(src.ProtocolConfig); err != nil {
			return err
		}
	}
	p.ProtocolConfig = _protocolConfig

	if src.ScenarioConfigs != nil {
		p.ScenarioConfigs = make(map[common.Scenario]*ScenarioConfig, len(src.ScenarioConfigs))
		for key, val := range src.ScenarioConfigs {
			var _key common.Scenario
			_key = key

			var _val *ScenarioConfig
			if val != nil {
				_val = &ScenarioConfig{}
				if err := _val.DeepCopy(val); err != nil {
					return err
				}
			}

			p.ScenarioConfigs[_key] = _val
		}
	}

	var _paramConfig *ParamConfig
	if src.ParamConfig != nil {
		_paramConfig = &ParamConfig{}
		if err := _paramConfig.DeepCopy(src.ParamConfig); err != nil {
			return err
		}
	}
	p.ParamConfig = _paramConfig

	return nil
}

func (p *Ability) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Ability[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *Ability) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxContextTokens = _field
	return offset, nil
}

func (p *Ability) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxInputTokens = _field
	return offset, nil
}

func (p *Ability) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxOutputTokens = _field
	return offset, nil
}

func (p *Ability) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.FunctionCall = _field
	return offset, nil
}

func (p *Ability) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.JSONMode = _field
	return offset, nil
}

func (p *Ability) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MultiModal = _field
	return offset, nil
}

func (p *Ability) FastReadField7(buf []byte) (int, error) {
	offset := 0
	_field := NewAbilityMultiModal()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AbilityMultiModal = _field
	return offset, nil
}

func (p *Ability) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Ability) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Ability) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Ability) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxContextTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxContextTokens)
	}
	return offset
}

func (p *Ability) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxInputTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxInputTokens)
	}
	return offset
}

func (p *Ability) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxOutputTokens() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxOutputTokens)
	}
	return offset
}

func (p *Ability) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFunctionCall() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 4)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.FunctionCall)
	}
	return offset
}

func (p *Ability) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetJSONMode() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 5)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.JSONMode)
	}
	return offset
}

func (p *Ability) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMultiModal() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 6)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.MultiModal)
	}
	return offset
}

func (p *Ability) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAbilityMultiModal() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 7)
		offset += p.AbilityMultiModal.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *Ability) field1Length() int {
	l := 0
	if p.IsSetMaxContextTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Ability) field2Length() int {
	l := 0
	if p.IsSetMaxInputTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Ability) field3Length() int {
	l := 0
	if p.IsSetMaxOutputTokens() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Ability) field4Length() int {
	l := 0
	if p.IsSetFunctionCall() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *Ability) field5Length() int {
	l := 0
	if p.IsSetJSONMode() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *Ability) field6Length() int {
	l := 0
	if p.IsSetMultiModal() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *Ability) field7Length() int {
	l := 0
	if p.IsSetAbilityMultiModal() {
		l += thrift.Binary.FieldBeginLength()
		l += p.AbilityMultiModal.BLength()
	}
	return l
}

func (p *Ability) DeepCopy(s interface{}) error {
	src, ok := s.(*Ability)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.MaxContextTokens != nil {
		tmp := *src.MaxContextTokens
		p.MaxContextTokens = &tmp
	}

	if src.MaxInputTokens != nil {
		tmp := *src.MaxInputTokens
		p.MaxInputTokens = &tmp
	}

	if src.MaxOutputTokens != nil {
		tmp := *src.MaxOutputTokens
		p.MaxOutputTokens = &tmp
	}

	if src.FunctionCall != nil {
		tmp := *src.FunctionCall
		p.FunctionCall = &tmp
	}

	if src.JSONMode != nil {
		tmp := *src.JSONMode
		p.JSONMode = &tmp
	}

	if src.MultiModal != nil {
		tmp := *src.MultiModal
		p.MultiModal = &tmp
	}

	var _abilityMultiModal *AbilityMultiModal
	if src.AbilityMultiModal != nil {
		_abilityMultiModal = &AbilityMultiModal{}
		if err := _abilityMultiModal.DeepCopy(src.AbilityMultiModal); err != nil {
			return err
		}
	}
	p.AbilityMultiModal = _abilityMultiModal

	return nil
}

func (p *AbilityMultiModal) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AbilityMultiModal[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AbilityMultiModal) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Image = _field
	return offset, nil
}

func (p *AbilityMultiModal) FastReadField2(buf []byte) (int, error) {
	offset := 0
	_field := NewAbilityImage()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AbilityImage = _field
	return offset, nil
}

func (p *AbilityMultiModal) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AbilityMultiModal) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AbilityMultiModal) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AbilityMultiModal) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetImage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 1)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.Image)
	}
	return offset
}

func (p *AbilityMultiModal) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAbilityImage() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 2)
		offset += p.AbilityImage.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *AbilityMultiModal) field1Length() int {
	l := 0
	if p.IsSetImage() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *AbilityMultiModal) field2Length() int {
	l := 0
	if p.IsSetAbilityImage() {
		l += thrift.Binary.FieldBeginLength()
		l += p.AbilityImage.BLength()
	}
	return l
}

func (p *AbilityMultiModal) DeepCopy(s interface{}) error {
	src, ok := s.(*AbilityMultiModal)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Image != nil {
		tmp := *src.Image
		p.Image = &tmp
	}

	var _abilityImage *AbilityImage
	if src.AbilityImage != nil {
		_abilityImage = &AbilityImage{}
		if err := _abilityImage.DeepCopy(src.AbilityImage); err != nil {
			return err
		}
	}
	p.AbilityImage = _abilityImage

	return nil
}

func (p *AbilityImage) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_AbilityImage[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *AbilityImage) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.URLEnabled = _field
	return offset, nil
}

func (p *AbilityImage) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.BinaryEnabled = _field
	return offset, nil
}

func (p *AbilityImage) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxImageSize = _field
	return offset, nil
}

func (p *AbilityImage) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.MaxImageCount = _field
	return offset, nil
}

func (p *AbilityImage) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *AbilityImage) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *AbilityImage) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *AbilityImage) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetURLEnabled() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 1)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.URLEnabled)
	}
	return offset
}

func (p *AbilityImage) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBinaryEnabled() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 2)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.BinaryEnabled)
	}
	return offset
}

func (p *AbilityImage) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxImageSize() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 3)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxImageSize)
	}
	return offset
}

func (p *AbilityImage) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMaxImageCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.MaxImageCount)
	}
	return offset
}

func (p *AbilityImage) field1Length() int {
	l := 0
	if p.IsSetURLEnabled() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *AbilityImage) field2Length() int {
	l := 0
	if p.IsSetBinaryEnabled() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *AbilityImage) field3Length() int {
	l := 0
	if p.IsSetMaxImageSize() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *AbilityImage) field4Length() int {
	l := 0
	if p.IsSetMaxImageCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *AbilityImage) DeepCopy(s interface{}) error {
	src, ok := s.(*AbilityImage)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.URLEnabled != nil {
		tmp := *src.URLEnabled
		p.URLEnabled = &tmp
	}

	if src.BinaryEnabled != nil {
		tmp := *src.BinaryEnabled
		p.BinaryEnabled = &tmp
	}

	if src.MaxImageSize != nil {
		tmp := *src.MaxImageSize
		p.MaxImageSize = &tmp
	}

	if src.MaxImageCount != nil {
		tmp := *src.MaxImageCount
		p.MaxImageCount = &tmp
	}

	return nil
}

func (p *ProtocolConfig) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfig[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfig) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.BaseURL = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.APIKey = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Model = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField4(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigArk()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigArk = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField5(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigOpenAI()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigOpenai = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField6(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigClaude()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigClaude = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField7(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigDeepSeek()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigDeepseek = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField8(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigOllama()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigOllama = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField9(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigQwen()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigQwen = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField10(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigQianfan()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigQianfan = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField11(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigGemini()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigGemini = _field
	return offset, nil
}

func (p *ProtocolConfig) FastReadField12(buf []byte) (int, error) {
	offset := 0
	_field := NewProtocolConfigArkbot()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ProtocolConfigArkbot = _field
	return offset, nil
}

func (p *ProtocolConfig) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfig) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
		offset += p.fastWriteField9(buf[offset:], w)
		offset += p.fastWriteField10(buf[offset:], w)
		offset += p.fastWriteField11(buf[offset:], w)
		offset += p.fastWriteField12(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfig) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfig) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetBaseURL() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.BaseURL)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAPIKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.APIKey)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetModel() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Model)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigArk() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 4)
		offset += p.ProtocolConfigArk.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigOpenai() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 5)
		offset += p.ProtocolConfigOpenai.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigClaude() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 6)
		offset += p.ProtocolConfigClaude.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigDeepseek() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 7)
		offset += p.ProtocolConfigDeepseek.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigOllama() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 8)
		offset += p.ProtocolConfigOllama.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField9(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigQwen() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 9)
		offset += p.ProtocolConfigQwen.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField10(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigQianfan() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 10)
		offset += p.ProtocolConfigQianfan.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField11(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigGemini() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 11)
		offset += p.ProtocolConfigGemini.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) fastWriteField12(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetProtocolConfigArkbot() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 12)
		offset += p.ProtocolConfigArkbot.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ProtocolConfig) field1Length() int {
	l := 0
	if p.IsSetBaseURL() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.BaseURL)
	}
	return l
}

func (p *ProtocolConfig) field2Length() int {
	l := 0
	if p.IsSetAPIKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.APIKey)
	}
	return l
}

func (p *ProtocolConfig) field3Length() int {
	l := 0
	if p.IsSetModel() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Model)
	}
	return l
}

func (p *ProtocolConfig) field4Length() int {
	l := 0
	if p.IsSetProtocolConfigArk() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigArk.BLength()
	}
	return l
}

func (p *ProtocolConfig) field5Length() int {
	l := 0
	if p.IsSetProtocolConfigOpenai() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigOpenai.BLength()
	}
	return l
}

func (p *ProtocolConfig) field6Length() int {
	l := 0
	if p.IsSetProtocolConfigClaude() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigClaude.BLength()
	}
	return l
}

func (p *ProtocolConfig) field7Length() int {
	l := 0
	if p.IsSetProtocolConfigDeepseek() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigDeepseek.BLength()
	}
	return l
}

func (p *ProtocolConfig) field8Length() int {
	l := 0
	if p.IsSetProtocolConfigOllama() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigOllama.BLength()
	}
	return l
}

func (p *ProtocolConfig) field9Length() int {
	l := 0
	if p.IsSetProtocolConfigQwen() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigQwen.BLength()
	}
	return l
}

func (p *ProtocolConfig) field10Length() int {
	l := 0
	if p.IsSetProtocolConfigQianfan() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigQianfan.BLength()
	}
	return l
}

func (p *ProtocolConfig) field11Length() int {
	l := 0
	if p.IsSetProtocolConfigGemini() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigGemini.BLength()
	}
	return l
}

func (p *ProtocolConfig) field12Length() int {
	l := 0
	if p.IsSetProtocolConfigArkbot() {
		l += thrift.Binary.FieldBeginLength()
		l += p.ProtocolConfigArkbot.BLength()
	}
	return l
}

func (p *ProtocolConfig) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfig)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.BaseURL != nil {
		var tmp string
		if *src.BaseURL != "" {
			tmp = kutils.StringDeepCopy(*src.BaseURL)
		}
		p.BaseURL = &tmp
	}

	if src.APIKey != nil {
		var tmp string
		if *src.APIKey != "" {
			tmp = kutils.StringDeepCopy(*src.APIKey)
		}
		p.APIKey = &tmp
	}

	if src.Model != nil {
		var tmp string
		if *src.Model != "" {
			tmp = kutils.StringDeepCopy(*src.Model)
		}
		p.Model = &tmp
	}

	var _protocolConfigArk *ProtocolConfigArk
	if src.ProtocolConfigArk != nil {
		_protocolConfigArk = &ProtocolConfigArk{}
		if err := _protocolConfigArk.DeepCopy(src.ProtocolConfigArk); err != nil {
			return err
		}
	}
	p.ProtocolConfigArk = _protocolConfigArk

	var _protocolConfigOpenai *ProtocolConfigOpenAI
	if src.ProtocolConfigOpenai != nil {
		_protocolConfigOpenai = &ProtocolConfigOpenAI{}
		if err := _protocolConfigOpenai.DeepCopy(src.ProtocolConfigOpenai); err != nil {
			return err
		}
	}
	p.ProtocolConfigOpenai = _protocolConfigOpenai

	var _protocolConfigClaude *ProtocolConfigClaude
	if src.ProtocolConfigClaude != nil {
		_protocolConfigClaude = &ProtocolConfigClaude{}
		if err := _protocolConfigClaude.DeepCopy(src.ProtocolConfigClaude); err != nil {
			return err
		}
	}
	p.ProtocolConfigClaude = _protocolConfigClaude

	var _protocolConfigDeepseek *ProtocolConfigDeepSeek
	if src.ProtocolConfigDeepseek != nil {
		_protocolConfigDeepseek = &ProtocolConfigDeepSeek{}
		if err := _protocolConfigDeepseek.DeepCopy(src.ProtocolConfigDeepseek); err != nil {
			return err
		}
	}
	p.ProtocolConfigDeepseek = _protocolConfigDeepseek

	var _protocolConfigOllama *ProtocolConfigOllama
	if src.ProtocolConfigOllama != nil {
		_protocolConfigOllama = &ProtocolConfigOllama{}
		if err := _protocolConfigOllama.DeepCopy(src.ProtocolConfigOllama); err != nil {
			return err
		}
	}
	p.ProtocolConfigOllama = _protocolConfigOllama

	var _protocolConfigQwen *ProtocolConfigQwen
	if src.ProtocolConfigQwen != nil {
		_protocolConfigQwen = &ProtocolConfigQwen{}
		if err := _protocolConfigQwen.DeepCopy(src.ProtocolConfigQwen); err != nil {
			return err
		}
	}
	p.ProtocolConfigQwen = _protocolConfigQwen

	var _protocolConfigQianfan *ProtocolConfigQianfan
	if src.ProtocolConfigQianfan != nil {
		_protocolConfigQianfan = &ProtocolConfigQianfan{}
		if err := _protocolConfigQianfan.DeepCopy(src.ProtocolConfigQianfan); err != nil {
			return err
		}
	}
	p.ProtocolConfigQianfan = _protocolConfigQianfan

	var _protocolConfigGemini *ProtocolConfigGemini
	if src.ProtocolConfigGemini != nil {
		_protocolConfigGemini = &ProtocolConfigGemini{}
		if err := _protocolConfigGemini.DeepCopy(src.ProtocolConfigGemini); err != nil {
			return err
		}
	}
	p.ProtocolConfigGemini = _protocolConfigGemini

	var _protocolConfigArkbot *ProtocolConfigArkbot
	if src.ProtocolConfigArkbot != nil {
		_protocolConfigArkbot = &ProtocolConfigArkbot{}
		if err := _protocolConfigArkbot.DeepCopy(src.ProtocolConfigArkbot); err != nil {
			return err
		}
	}
	p.ProtocolConfigArkbot = _protocolConfigArkbot

	return nil
}

func (p *ProtocolConfigArk) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigArk[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigArk) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Region = _field
	return offset, nil
}

func (p *ProtocolConfigArk) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AccessKey = _field
	return offset, nil
}

func (p *ProtocolConfigArk) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SecretKey = _field
	return offset, nil
}

func (p *ProtocolConfigArk) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.RetryTimes = _field
	return offset, nil
}

func (p *ProtocolConfigArk) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		var _val string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_val = v
		}

		_field[_key] = _val
	}
	p.CustomHeaders = _field
	return offset, nil
}

func (p *ProtocolConfigArk) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigArk) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigArk) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigArk) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRegion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Region)
	}
	return offset
}

func (p *ProtocolConfigArk) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAccessKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.AccessKey)
	}
	return offset
}

func (p *ProtocolConfigArk) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSecretKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SecretKey)
	}
	return offset
}

func (p *ProtocolConfigArk) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRetryTimes() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.RetryTimes)
	}
	return offset
}

func (p *ProtocolConfigArk) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCustomHeaders() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 5)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.CustomHeaders {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, k)
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, v)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
	}
	return offset
}

func (p *ProtocolConfigArk) field1Length() int {
	l := 0
	if p.IsSetRegion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Region)
	}
	return l
}

func (p *ProtocolConfigArk) field2Length() int {
	l := 0
	if p.IsSetAccessKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.AccessKey)
	}
	return l
}

func (p *ProtocolConfigArk) field3Length() int {
	l := 0
	if p.IsSetSecretKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SecretKey)
	}
	return l
}

func (p *ProtocolConfigArk) field4Length() int {
	l := 0
	if p.IsSetRetryTimes() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ProtocolConfigArk) field5Length() int {
	l := 0
	if p.IsSetCustomHeaders() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.CustomHeaders {
			_, _ = k, v

			l += thrift.Binary.StringLengthNocopy(k)
			l += thrift.Binary.StringLengthNocopy(v)
		}
	}
	return l
}

func (p *ProtocolConfigArk) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigArk)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Region != nil {
		var tmp string
		if *src.Region != "" {
			tmp = kutils.StringDeepCopy(*src.Region)
		}
		p.Region = &tmp
	}

	if src.AccessKey != nil {
		var tmp string
		if *src.AccessKey != "" {
			tmp = kutils.StringDeepCopy(*src.AccessKey)
		}
		p.AccessKey = &tmp
	}

	if src.SecretKey != nil {
		var tmp string
		if *src.SecretKey != "" {
			tmp = kutils.StringDeepCopy(*src.SecretKey)
		}
		p.SecretKey = &tmp
	}

	if src.RetryTimes != nil {
		tmp := *src.RetryTimes
		p.RetryTimes = &tmp
	}

	if src.CustomHeaders != nil {
		p.CustomHeaders = make(map[string]string, len(src.CustomHeaders))
		for key, val := range src.CustomHeaders {
			var _key string
			if key != "" {
				_key = kutils.StringDeepCopy(key)
			}

			var _val string
			if val != "" {
				_val = kutils.StringDeepCopy(val)
			}

			p.CustomHeaders[_key] = _val
		}
	}

	return nil
}

func (p *ProtocolConfigOpenAI) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigOpenAI[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigOpenAI) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ByAzure = _field
	return offset, nil
}

func (p *ProtocolConfigOpenAI) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.APIVersion = _field
	return offset, nil
}

func (p *ProtocolConfigOpenAI) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatType = _field
	return offset, nil
}

func (p *ProtocolConfigOpenAI) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatJSONSchema = _field
	return offset, nil
}

func (p *ProtocolConfigOpenAI) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigOpenAI) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigOpenAI) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigOpenAI) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetByAzure() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 1)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.ByAzure)
	}
	return offset
}

func (p *ProtocolConfigOpenAI) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAPIVersion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.APIVersion)
	}
	return offset
}

func (p *ProtocolConfigOpenAI) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatType)
	}
	return offset
}

func (p *ProtocolConfigOpenAI) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatJSONSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatJSONSchema)
	}
	return offset
}

func (p *ProtocolConfigOpenAI) field1Length() int {
	l := 0
	if p.IsSetByAzure() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *ProtocolConfigOpenAI) field2Length() int {
	l := 0
	if p.IsSetAPIVersion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.APIVersion)
	}
	return l
}

func (p *ProtocolConfigOpenAI) field3Length() int {
	l := 0
	if p.IsSetResponseFormatType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatType)
	}
	return l
}

func (p *ProtocolConfigOpenAI) field4Length() int {
	l := 0
	if p.IsSetResponseFormatJSONSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatJSONSchema)
	}
	return l
}

func (p *ProtocolConfigOpenAI) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigOpenAI)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ByAzure != nil {
		tmp := *src.ByAzure
		p.ByAzure = &tmp
	}

	if src.APIVersion != nil {
		var tmp string
		if *src.APIVersion != "" {
			tmp = kutils.StringDeepCopy(*src.APIVersion)
		}
		p.APIVersion = &tmp
	}

	if src.ResponseFormatType != nil {
		var tmp string
		if *src.ResponseFormatType != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatType)
		}
		p.ResponseFormatType = &tmp
	}

	if src.ResponseFormatJSONSchema != nil {
		var tmp string
		if *src.ResponseFormatJSONSchema != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatJSONSchema)
		}
		p.ResponseFormatJSONSchema = &tmp
	}

	return nil
}

func (p *ProtocolConfigClaude) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigClaude[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigClaude) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ByBedrock = _field
	return offset, nil
}

func (p *ProtocolConfigClaude) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AccessKey = _field
	return offset, nil
}

func (p *ProtocolConfigClaude) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SecretAccessKey = _field
	return offset, nil
}

func (p *ProtocolConfigClaude) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SessionToken = _field
	return offset, nil
}

func (p *ProtocolConfigClaude) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Region = _field
	return offset, nil
}

func (p *ProtocolConfigClaude) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigClaude) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigClaude) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigClaude) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetByBedrock() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 1)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.ByBedrock)
	}
	return offset
}

func (p *ProtocolConfigClaude) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAccessKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.AccessKey)
	}
	return offset
}

func (p *ProtocolConfigClaude) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSecretAccessKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SecretAccessKey)
	}
	return offset
}

func (p *ProtocolConfigClaude) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSessionToken() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SessionToken)
	}
	return offset
}

func (p *ProtocolConfigClaude) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRegion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Region)
	}
	return offset
}

func (p *ProtocolConfigClaude) field1Length() int {
	l := 0
	if p.IsSetByBedrock() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *ProtocolConfigClaude) field2Length() int {
	l := 0
	if p.IsSetAccessKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.AccessKey)
	}
	return l
}

func (p *ProtocolConfigClaude) field3Length() int {
	l := 0
	if p.IsSetSecretAccessKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SecretAccessKey)
	}
	return l
}

func (p *ProtocolConfigClaude) field4Length() int {
	l := 0
	if p.IsSetSessionToken() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SessionToken)
	}
	return l
}

func (p *ProtocolConfigClaude) field5Length() int {
	l := 0
	if p.IsSetRegion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Region)
	}
	return l
}

func (p *ProtocolConfigClaude) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigClaude)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ByBedrock != nil {
		tmp := *src.ByBedrock
		p.ByBedrock = &tmp
	}

	if src.AccessKey != nil {
		var tmp string
		if *src.AccessKey != "" {
			tmp = kutils.StringDeepCopy(*src.AccessKey)
		}
		p.AccessKey = &tmp
	}

	if src.SecretAccessKey != nil {
		var tmp string
		if *src.SecretAccessKey != "" {
			tmp = kutils.StringDeepCopy(*src.SecretAccessKey)
		}
		p.SecretAccessKey = &tmp
	}

	if src.SessionToken != nil {
		var tmp string
		if *src.SessionToken != "" {
			tmp = kutils.StringDeepCopy(*src.SessionToken)
		}
		p.SessionToken = &tmp
	}

	if src.Region != nil {
		var tmp string
		if *src.Region != "" {
			tmp = kutils.StringDeepCopy(*src.Region)
		}
		p.Region = &tmp
	}

	return nil
}

func (p *ProtocolConfigDeepSeek) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigDeepSeek[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigDeepSeek) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatType = _field
	return offset, nil
}

func (p *ProtocolConfigDeepSeek) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigDeepSeek) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigDeepSeek) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigDeepSeek) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatType)
	}
	return offset
}

func (p *ProtocolConfigDeepSeek) field1Length() int {
	l := 0
	if p.IsSetResponseFormatType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatType)
	}
	return l
}

func (p *ProtocolConfigDeepSeek) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigDeepSeek)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ResponseFormatType != nil {
		var tmp string
		if *src.ResponseFormatType != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatType)
		}
		p.ResponseFormatType = &tmp
	}

	return nil
}

func (p *ProtocolConfigGemini) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigGemini[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigGemini) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseSchema = _field
	return offset, nil
}

func (p *ProtocolConfigGemini) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.EnableCodeExecution = _field
	return offset, nil
}

func (p *ProtocolConfigGemini) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ProtocolConfigGeminiSafetySetting, 0, size)
	values := make([]ProtocolConfigGeminiSafetySetting, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.SafetySettings = _field
	return offset, nil
}

func (p *ProtocolConfigGemini) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigGemini) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigGemini) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigGemini) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseSchema)
	}
	return offset
}

func (p *ProtocolConfigGemini) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetEnableCodeExecution() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 2)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.EnableCodeExecution)
	}
	return offset
}

func (p *ProtocolConfigGemini) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSafetySettings() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 3)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.SafetySettings {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ProtocolConfigGemini) field1Length() int {
	l := 0
	if p.IsSetResponseSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseSchema)
	}
	return l
}

func (p *ProtocolConfigGemini) field2Length() int {
	l := 0
	if p.IsSetEnableCodeExecution() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *ProtocolConfigGemini) field3Length() int {
	l := 0
	if p.IsSetSafetySettings() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.SafetySettings {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ProtocolConfigGemini) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigGemini)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ResponseSchema != nil {
		var tmp string
		if *src.ResponseSchema != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseSchema)
		}
		p.ResponseSchema = &tmp
	}

	if src.EnableCodeExecution != nil {
		tmp := *src.EnableCodeExecution
		p.EnableCodeExecution = &tmp
	}

	if src.SafetySettings != nil {
		p.SafetySettings = make([]*ProtocolConfigGeminiSafetySetting, 0, len(src.SafetySettings))
		for _, elem := range src.SafetySettings {
			var _elem *ProtocolConfigGeminiSafetySetting
			if elem != nil {
				_elem = &ProtocolConfigGeminiSafetySetting{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.SafetySettings = append(p.SafetySettings, _elem)
		}
	}

	return nil
}

func (p *ProtocolConfigGeminiSafetySetting) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigGeminiSafetySetting[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigGeminiSafetySetting) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Category = _field
	return offset, nil
}

func (p *ProtocolConfigGeminiSafetySetting) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Threshold = _field
	return offset, nil
}

func (p *ProtocolConfigGeminiSafetySetting) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigGeminiSafetySetting) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigGeminiSafetySetting) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigGeminiSafetySetting) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCategory() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.Category)
	}
	return offset
}

func (p *ProtocolConfigGeminiSafetySetting) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetThreshold() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 2)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.Threshold)
	}
	return offset
}

func (p *ProtocolConfigGeminiSafetySetting) field1Length() int {
	l := 0
	if p.IsSetCategory() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ProtocolConfigGeminiSafetySetting) field2Length() int {
	l := 0
	if p.IsSetThreshold() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ProtocolConfigGeminiSafetySetting) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigGeminiSafetySetting)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Category != nil {
		tmp := *src.Category
		p.Category = &tmp
	}

	if src.Threshold != nil {
		tmp := *src.Threshold
		p.Threshold = &tmp
	}

	return nil
}

func (p *ProtocolConfigOllama) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigOllama[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigOllama) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Format = _field
	return offset, nil
}

func (p *ProtocolConfigOllama) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.KeepAliveMs = _field
	return offset, nil
}

func (p *ProtocolConfigOllama) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigOllama) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigOllama) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigOllama) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetFormat() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Format)
	}
	return offset
}

func (p *ProtocolConfigOllama) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetKeepAliveMs() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.KeepAliveMs)
	}
	return offset
}

func (p *ProtocolConfigOllama) field1Length() int {
	l := 0
	if p.IsSetFormat() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Format)
	}
	return l
}

func (p *ProtocolConfigOllama) field2Length() int {
	l := 0
	if p.IsSetKeepAliveMs() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ProtocolConfigOllama) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigOllama)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Format != nil {
		var tmp string
		if *src.Format != "" {
			tmp = kutils.StringDeepCopy(*src.Format)
		}
		p.Format = &tmp
	}

	if src.KeepAliveMs != nil {
		tmp := *src.KeepAliveMs
		p.KeepAliveMs = &tmp
	}

	return nil
}

func (p *ProtocolConfigQwen) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigQwen[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigQwen) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatType = _field
	return offset, nil
}

func (p *ProtocolConfigQwen) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatJSONSchema = _field
	return offset, nil
}

func (p *ProtocolConfigQwen) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigQwen) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigQwen) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigQwen) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatType)
	}
	return offset
}

func (p *ProtocolConfigQwen) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatJSONSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatJSONSchema)
	}
	return offset
}

func (p *ProtocolConfigQwen) field1Length() int {
	l := 0
	if p.IsSetResponseFormatType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatType)
	}
	return l
}

func (p *ProtocolConfigQwen) field2Length() int {
	l := 0
	if p.IsSetResponseFormatJSONSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatJSONSchema)
	}
	return l
}

func (p *ProtocolConfigQwen) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigQwen)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ResponseFormatType != nil {
		var tmp string
		if *src.ResponseFormatType != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatType)
		}
		p.ResponseFormatType = &tmp
	}

	if src.ResponseFormatJSONSchema != nil {
		var tmp string
		if *src.ResponseFormatJSONSchema != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatJSONSchema)
		}
		p.ResponseFormatJSONSchema = &tmp
	}

	return nil
}

func (p *ProtocolConfigQianfan) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigQianfan[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigQianfan) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int32
	if v, l, err := thrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.LlmRetryCount = _field
	return offset, nil
}

func (p *ProtocolConfigQianfan) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.LlmRetryTimeout = _field
	return offset, nil
}

func (p *ProtocolConfigQianfan) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *float64
	if v, l, err := thrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.LlmRetryBackoffFactor = _field
	return offset, nil
}

func (p *ProtocolConfigQianfan) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ParallelToolCalls = _field
	return offset, nil
}

func (p *ProtocolConfigQianfan) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatType = _field
	return offset, nil
}

func (p *ProtocolConfigQianfan) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.ResponseFormatJSONSchema = _field
	return offset, nil
}

func (p *ProtocolConfigQianfan) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigQianfan) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigQianfan) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigQianfan) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLlmRetryCount() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I32, 1)
		offset += thrift.Binary.WriteI32(buf[offset:], *p.LlmRetryCount)
	}
	return offset
}

func (p *ProtocolConfigQianfan) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLlmRetryTimeout() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 2)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.LlmRetryTimeout)
	}
	return offset
}

func (p *ProtocolConfigQianfan) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLlmRetryBackoffFactor() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.DOUBLE, 3)
		offset += thrift.Binary.WriteDouble(buf[offset:], *p.LlmRetryBackoffFactor)
	}
	return offset
}

func (p *ProtocolConfigQianfan) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetParallelToolCalls() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 4)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.ParallelToolCalls)
	}
	return offset
}

func (p *ProtocolConfigQianfan) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatType)
	}
	return offset
}

func (p *ProtocolConfigQianfan) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetResponseFormatJSONSchema() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.ResponseFormatJSONSchema)
	}
	return offset
}

func (p *ProtocolConfigQianfan) field1Length() int {
	l := 0
	if p.IsSetLlmRetryCount() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I32Length()
	}
	return l
}

func (p *ProtocolConfigQianfan) field2Length() int {
	l := 0
	if p.IsSetLlmRetryTimeout() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *ProtocolConfigQianfan) field3Length() int {
	l := 0
	if p.IsSetLlmRetryBackoffFactor() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.DoubleLength()
	}
	return l
}

func (p *ProtocolConfigQianfan) field4Length() int {
	l := 0
	if p.IsSetParallelToolCalls() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *ProtocolConfigQianfan) field5Length() int {
	l := 0
	if p.IsSetResponseFormatType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatType)
	}
	return l
}

func (p *ProtocolConfigQianfan) field6Length() int {
	l := 0
	if p.IsSetResponseFormatJSONSchema() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.ResponseFormatJSONSchema)
	}
	return l
}

func (p *ProtocolConfigQianfan) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigQianfan)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.LlmRetryCount != nil {
		tmp := *src.LlmRetryCount
		p.LlmRetryCount = &tmp
	}

	if src.LlmRetryTimeout != nil {
		tmp := *src.LlmRetryTimeout
		p.LlmRetryTimeout = &tmp
	}

	if src.LlmRetryBackoffFactor != nil {
		tmp := *src.LlmRetryBackoffFactor
		p.LlmRetryBackoffFactor = &tmp
	}

	if src.ParallelToolCalls != nil {
		tmp := *src.ParallelToolCalls
		p.ParallelToolCalls = &tmp
	}

	if src.ResponseFormatType != nil {
		var tmp string
		if *src.ResponseFormatType != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatType)
		}
		p.ResponseFormatType = &tmp
	}

	if src.ResponseFormatJSONSchema != nil {
		var tmp string
		if *src.ResponseFormatJSONSchema != "" {
			tmp = kutils.StringDeepCopy(*src.ResponseFormatJSONSchema)
		}
		p.ResponseFormatJSONSchema = &tmp
	}

	return nil
}

func (p *ProtocolConfigArkbot) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ProtocolConfigArkbot[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ProtocolConfigArkbot) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Region = _field
	return offset, nil
}

func (p *ProtocolConfigArkbot) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.AccessKey = _field
	return offset, nil
}

func (p *ProtocolConfigArkbot) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.SecretKey = _field
	return offset, nil
}

func (p *ProtocolConfigArkbot) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.RetryTimes = _field
	return offset, nil
}

func (p *ProtocolConfigArkbot) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := thrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_key = v
		}

		var _val string
		if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
			_val = v
		}

		_field[_key] = _val
	}
	p.CustomHeaders = _field
	return offset, nil
}

func (p *ProtocolConfigArkbot) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ProtocolConfigArkbot) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ProtocolConfigArkbot) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ProtocolConfigArkbot) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRegion() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Region)
	}
	return offset
}

func (p *ProtocolConfigArkbot) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetAccessKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.AccessKey)
	}
	return offset
}

func (p *ProtocolConfigArkbot) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetSecretKey() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.SecretKey)
	}
	return offset
}

func (p *ProtocolConfigArkbot) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetRetryTimes() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 4)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.RetryTimes)
	}
	return offset
}

func (p *ProtocolConfigArkbot) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetCustomHeaders() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.MAP, 5)
		mapBeginOffset := offset
		offset += thrift.Binary.MapBeginLength()
		var length int
		for k, v := range p.CustomHeaders {
			length++
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, k)
			offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, v)
		}
		thrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
	}
	return offset
}

func (p *ProtocolConfigArkbot) field1Length() int {
	l := 0
	if p.IsSetRegion() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Region)
	}
	return l
}

func (p *ProtocolConfigArkbot) field2Length() int {
	l := 0
	if p.IsSetAccessKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.AccessKey)
	}
	return l
}

func (p *ProtocolConfigArkbot) field3Length() int {
	l := 0
	if p.IsSetSecretKey() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.SecretKey)
	}
	return l
}

func (p *ProtocolConfigArkbot) field4Length() int {
	l := 0
	if p.IsSetRetryTimes() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *ProtocolConfigArkbot) field5Length() int {
	l := 0
	if p.IsSetCustomHeaders() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.MapBeginLength()
		for k, v := range p.CustomHeaders {
			_, _ = k, v

			l += thrift.Binary.StringLengthNocopy(k)
			l += thrift.Binary.StringLengthNocopy(v)
		}
	}
	return l
}

func (p *ProtocolConfigArkbot) DeepCopy(s interface{}) error {
	src, ok := s.(*ProtocolConfigArkbot)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Region != nil {
		var tmp string
		if *src.Region != "" {
			tmp = kutils.StringDeepCopy(*src.Region)
		}
		p.Region = &tmp
	}

	if src.AccessKey != nil {
		var tmp string
		if *src.AccessKey != "" {
			tmp = kutils.StringDeepCopy(*src.AccessKey)
		}
		p.AccessKey = &tmp
	}

	if src.SecretKey != nil {
		var tmp string
		if *src.SecretKey != "" {
			tmp = kutils.StringDeepCopy(*src.SecretKey)
		}
		p.SecretKey = &tmp
	}

	if src.RetryTimes != nil {
		tmp := *src.RetryTimes
		p.RetryTimes = &tmp
	}

	if src.CustomHeaders != nil {
		p.CustomHeaders = make(map[string]string, len(src.CustomHeaders))
		for key, val := range src.CustomHeaders {
			var _key string
			if key != "" {
				_key = kutils.StringDeepCopy(key)
			}

			var _val string
			if val != "" {
				_val = kutils.StringDeepCopy(val)
			}

			p.CustomHeaders[_key] = _val
		}
	}

	return nil
}

func (p *ScenarioConfig) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ScenarioConfig[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ScenarioConfig) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *common.Scenario
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Scenario = _field
	return offset, nil
}

func (p *ScenarioConfig) FastReadField3(buf []byte) (int, error) {
	offset := 0
	_field := NewQuota()
	if l, err := _field.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Quota = _field
	return offset, nil
}

func (p *ScenarioConfig) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *bool
	if v, l, err := thrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Unavailable = _field
	return offset, nil
}

func (p *ScenarioConfig) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ScenarioConfig) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ScenarioConfig) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ScenarioConfig) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetScenario() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Scenario)
	}
	return offset
}

func (p *ScenarioConfig) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetQuota() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRUCT, 3)
		offset += p.Quota.FastWriteNocopy(buf[offset:], w)
	}
	return offset
}

func (p *ScenarioConfig) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetUnavailable() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.BOOL, 4)
		offset += thrift.Binary.WriteBool(buf[offset:], *p.Unavailable)
	}
	return offset
}

func (p *ScenarioConfig) field1Length() int {
	l := 0
	if p.IsSetScenario() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Scenario)
	}
	return l
}

func (p *ScenarioConfig) field3Length() int {
	l := 0
	if p.IsSetQuota() {
		l += thrift.Binary.FieldBeginLength()
		l += p.Quota.BLength()
	}
	return l
}

func (p *ScenarioConfig) field4Length() int {
	l := 0
	if p.IsSetUnavailable() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.BoolLength()
	}
	return l
}

func (p *ScenarioConfig) DeepCopy(s interface{}) error {
	src, ok := s.(*ScenarioConfig)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Scenario != nil {
		tmp := *src.Scenario
		p.Scenario = &tmp
	}

	var _quota *Quota
	if src.Quota != nil {
		_quota = &Quota{}
		if err := _quota.DeepCopy(src.Quota); err != nil {
			return err
		}
	}
	p.Quota = _quota

	if src.Unavailable != nil {
		tmp := *src.Unavailable
		p.Unavailable = &tmp
	}

	return nil
}

func (p *ParamConfig) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ParamConfig[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ParamConfig) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ParamSchema, 0, size)
	values := make([]ParamSchema, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.ParamSchemas = _field
	return offset, nil
}

func (p *ParamConfig) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ParamConfig) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ParamConfig) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ParamConfig) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetParamSchemas() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 1)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.ParamSchemas {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ParamConfig) field1Length() int {
	l := 0
	if p.IsSetParamSchemas() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.ParamSchemas {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ParamConfig) DeepCopy(s interface{}) error {
	src, ok := s.(*ParamConfig)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.ParamSchemas != nil {
		p.ParamSchemas = make([]*ParamSchema, 0, len(src.ParamSchemas))
		for _, elem := range src.ParamSchemas {
			var _elem *ParamSchema
			if elem != nil {
				_elem = &ParamSchema{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.ParamSchemas = append(p.ParamSchemas, _elem)
		}
	}

	return nil
}

func (p *ParamSchema) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ParamSchema[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ParamSchema) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Name = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Label = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField3(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Desc = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField4(buf []byte) (int, error) {
	offset := 0

	var _field *ParamType
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Type = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField5(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Min = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField6(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Max = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField7(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.DefaultValue = _field
	return offset, nil
}

func (p *ParamSchema) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := thrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	_field := make([]*ParamOption, 0, size)
	values := make([]ParamOption, size)
	for i := 0; i < size; i++ {
		_elem := &values[i]
		_elem.InitDefault()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		_field = append(_field, _elem)
	}
	p.Options = _field
	return offset, nil
}

func (p *ParamSchema) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ParamSchema) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
		offset += p.fastWriteField3(buf[offset:], w)
		offset += p.fastWriteField4(buf[offset:], w)
		offset += p.fastWriteField5(buf[offset:], w)
		offset += p.fastWriteField6(buf[offset:], w)
		offset += p.fastWriteField7(buf[offset:], w)
		offset += p.fastWriteField8(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ParamSchema) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ParamSchema) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Name)
	}
	return offset
}

func (p *ParamSchema) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLabel() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Label)
	}
	return offset
}

func (p *ParamSchema) fastWriteField3(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDesc() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 3)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Desc)
	}
	return offset
}

func (p *ParamSchema) fastWriteField4(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 4)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Type)
	}
	return offset
}

func (p *ParamSchema) fastWriteField5(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMin() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 5)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Min)
	}
	return offset
}

func (p *ParamSchema) fastWriteField6(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetMax() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 6)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Max)
	}
	return offset
}

func (p *ParamSchema) fastWriteField7(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetDefaultValue() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 7)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.DefaultValue)
	}
	return offset
}

func (p *ParamSchema) fastWriteField8(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetOptions() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.LIST, 8)
		listBeginOffset := offset
		offset += thrift.Binary.ListBeginLength()
		var length int
		for _, v := range p.Options {
			length++
			offset += v.FastWriteNocopy(buf[offset:], w)
		}
		thrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	}
	return offset
}

func (p *ParamSchema) field1Length() int {
	l := 0
	if p.IsSetName() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Name)
	}
	return l
}

func (p *ParamSchema) field2Length() int {
	l := 0
	if p.IsSetLabel() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Label)
	}
	return l
}

func (p *ParamSchema) field3Length() int {
	l := 0
	if p.IsSetDesc() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Desc)
	}
	return l
}

func (p *ParamSchema) field4Length() int {
	l := 0
	if p.IsSetType() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Type)
	}
	return l
}

func (p *ParamSchema) field5Length() int {
	l := 0
	if p.IsSetMin() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Min)
	}
	return l
}

func (p *ParamSchema) field6Length() int {
	l := 0
	if p.IsSetMax() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Max)
	}
	return l
}

func (p *ParamSchema) field7Length() int {
	l := 0
	if p.IsSetDefaultValue() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.DefaultValue)
	}
	return l
}

func (p *ParamSchema) field8Length() int {
	l := 0
	if p.IsSetOptions() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.ListBeginLength()
		for _, v := range p.Options {
			_ = v
			l += v.BLength()
		}
	}
	return l
}

func (p *ParamSchema) DeepCopy(s interface{}) error {
	src, ok := s.(*ParamSchema)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Name != nil {
		var tmp string
		if *src.Name != "" {
			tmp = kutils.StringDeepCopy(*src.Name)
		}
		p.Name = &tmp
	}

	if src.Label != nil {
		var tmp string
		if *src.Label != "" {
			tmp = kutils.StringDeepCopy(*src.Label)
		}
		p.Label = &tmp
	}

	if src.Desc != nil {
		var tmp string
		if *src.Desc != "" {
			tmp = kutils.StringDeepCopy(*src.Desc)
		}
		p.Desc = &tmp
	}

	if src.Type != nil {
		tmp := *src.Type
		p.Type = &tmp
	}

	if src.Min != nil {
		var tmp string
		if *src.Min != "" {
			tmp = kutils.StringDeepCopy(*src.Min)
		}
		p.Min = &tmp
	}

	if src.Max != nil {
		var tmp string
		if *src.Max != "" {
			tmp = kutils.StringDeepCopy(*src.Max)
		}
		p.Max = &tmp
	}

	if src.DefaultValue != nil {
		var tmp string
		if *src.DefaultValue != "" {
			tmp = kutils.StringDeepCopy(*src.DefaultValue)
		}
		p.DefaultValue = &tmp
	}

	if src.Options != nil {
		p.Options = make([]*ParamOption, 0, len(src.Options))
		for _, elem := range src.Options {
			var _elem *ParamOption
			if elem != nil {
				_elem = &ParamOption{}
				if err := _elem.DeepCopy(elem); err != nil {
					return err
				}
			}

			p.Options = append(p.Options, _elem)
		}
	}

	return nil
}

func (p *ParamOption) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_ParamOption[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *ParamOption) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Value = _field
	return offset, nil
}

func (p *ParamOption) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *string
	if v, l, err := thrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Label = _field
	return offset, nil
}

func (p *ParamOption) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *ParamOption) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *ParamOption) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *ParamOption) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetValue() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 1)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Value)
	}
	return offset
}

func (p *ParamOption) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetLabel() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.STRING, 2)
		offset += thrift.Binary.WriteStringNocopy(buf[offset:], w, *p.Label)
	}
	return offset
}

func (p *ParamOption) field1Length() int {
	l := 0
	if p.IsSetValue() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Value)
	}
	return l
}

func (p *ParamOption) field2Length() int {
	l := 0
	if p.IsSetLabel() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.StringLengthNocopy(*p.Label)
	}
	return l
}

func (p *ParamOption) DeepCopy(s interface{}) error {
	src, ok := s.(*ParamOption)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Value != nil {
		var tmp string
		if *src.Value != "" {
			tmp = kutils.StringDeepCopy(*src.Value)
		}
		p.Value = &tmp
	}

	if src.Label != nil {
		var tmp string
		if *src.Label != "" {
			tmp = kutils.StringDeepCopy(*src.Label)
		}
		p.Label = &tmp
	}

	return nil
}

func (p *Quota) FastRead(buf []byte) (int, error) {

	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	for {
		fieldTypeId, fieldId, l, err = thrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = thrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}

	return offset, nil
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_Quota[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
}

func (p *Quota) FastReadField1(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Qpm = _field
	return offset, nil
}

func (p *Quota) FastReadField2(buf []byte) (int, error) {
	offset := 0

	var _field *int64
	if v, l, err := thrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		_field = &v
	}
	p.Tpm = _field
	return offset, nil
}

func (p *Quota) FastWrite(buf []byte) int {
	return p.FastWriteNocopy(buf, nil)
}

func (p *Quota) FastWriteNocopy(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], w)
		offset += p.fastWriteField2(buf[offset:], w)
	}
	offset += thrift.Binary.WriteFieldStop(buf[offset:])
	return offset
}

func (p *Quota) BLength() int {
	l := 0
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += thrift.Binary.FieldStopLength()
	return l
}

func (p *Quota) fastWriteField1(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetQpm() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 1)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.Qpm)
	}
	return offset
}

func (p *Quota) fastWriteField2(buf []byte, w thrift.NocopyWriter) int {
	offset := 0
	if p.IsSetTpm() {
		offset += thrift.Binary.WriteFieldBegin(buf[offset:], thrift.I64, 2)
		offset += thrift.Binary.WriteI64(buf[offset:], *p.Tpm)
	}
	return offset
}

func (p *Quota) field1Length() int {
	l := 0
	if p.IsSetQpm() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Quota) field2Length() int {
	l := 0
	if p.IsSetTpm() {
		l += thrift.Binary.FieldBeginLength()
		l += thrift.Binary.I64Length()
	}
	return l
}

func (p *Quota) DeepCopy(s interface{}) error {
	src, ok := s.(*Quota)
	if !ok {
		return fmt.Errorf("%T's type not matched %T", s, p)
	}

	if src.Qpm != nil {
		tmp := *src.Qpm
		p.Qpm = &tmp
	}

	if src.Tpm != nil {
		tmp := *src.Tpm
		p.Tpm = &tmp
	}

	return nil
}
