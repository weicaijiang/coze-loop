// Code generated by cozeloop. DO NOT EDIT.
package loauthn // import github.com/coze-dev/cozeloop/backend/loauthn

import (
	"context"

	"github.com/cloudwego/kitex/client/callopt"
	"github.com/cloudwego/kitex/pkg/endpoint"
	"github.com/cloudwego/kitex/pkg/rpcinfo"
	"github.com/coze-dev/cozeloop/backend/kitex_gen/coze/loop/foundation/authn"
)

type LocalAuthNService struct {
	impl authn.AuthNService // the service implementation
	mds  endpoint.Middleware
}

func NewLocalAuthNService(impl authn.AuthNService, mds ...endpoint.Middleware) *LocalAuthNService {
	return &LocalAuthNService{
		impl: impl,
		mds:  endpoint.Chain(mds...),
	}
}

// CreatePersonalAccessToken
// OpenAPI PAT管理
func (l *LocalAuthNService) CreatePersonalAccessToken(ctx context.Context, req *authn.CreatePersonalAccessTokenRequest, callOptions ...callopt.Option) (*authn.CreatePersonalAccessTokenResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*authn.AuthNServiceCreatePersonalAccessTokenArgs)
		result := out.(*authn.AuthNServiceCreatePersonalAccessTokenResult)
		resp, err := l.impl.CreatePersonalAccessToken(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &authn.AuthNServiceCreatePersonalAccessTokenArgs{Req: req}
	result := &authn.AuthNServiceCreatePersonalAccessTokenResult{}
	ctx = l.injectRPCInfo(ctx, "CreatePersonalAccessToken")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalAuthNService) DeletePersonalAccessToken(ctx context.Context, req *authn.DeletePersonalAccessTokenRequest, callOptions ...callopt.Option) (*authn.DeletePersonalAccessTokenResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*authn.AuthNServiceDeletePersonalAccessTokenArgs)
		result := out.(*authn.AuthNServiceDeletePersonalAccessTokenResult)
		resp, err := l.impl.DeletePersonalAccessToken(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &authn.AuthNServiceDeletePersonalAccessTokenArgs{Req: req}
	result := &authn.AuthNServiceDeletePersonalAccessTokenResult{}
	ctx = l.injectRPCInfo(ctx, "DeletePersonalAccessToken")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalAuthNService) UpdatePersonalAccessToken(ctx context.Context, req *authn.UpdatePersonalAccessTokenRequest, callOptions ...callopt.Option) (*authn.UpdatePersonalAccessTokenResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*authn.AuthNServiceUpdatePersonalAccessTokenArgs)
		result := out.(*authn.AuthNServiceUpdatePersonalAccessTokenResult)
		resp, err := l.impl.UpdatePersonalAccessToken(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &authn.AuthNServiceUpdatePersonalAccessTokenArgs{Req: req}
	result := &authn.AuthNServiceUpdatePersonalAccessTokenResult{}
	ctx = l.injectRPCInfo(ctx, "UpdatePersonalAccessToken")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalAuthNService) GetPersonalAccessToken(ctx context.Context, req *authn.GetPersonalAccessTokenRequest, callOptions ...callopt.Option) (*authn.GetPersonalAccessTokenResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*authn.AuthNServiceGetPersonalAccessTokenArgs)
		result := out.(*authn.AuthNServiceGetPersonalAccessTokenResult)
		resp, err := l.impl.GetPersonalAccessToken(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &authn.AuthNServiceGetPersonalAccessTokenArgs{Req: req}
	result := &authn.AuthNServiceGetPersonalAccessTokenResult{}
	ctx = l.injectRPCInfo(ctx, "GetPersonalAccessToken")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalAuthNService) ListPersonalAccessToken(ctx context.Context, req *authn.ListPersonalAccessTokenRequest, callOptions ...callopt.Option) (*authn.ListPersonalAccessTokenResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*authn.AuthNServiceListPersonalAccessTokenArgs)
		result := out.(*authn.AuthNServiceListPersonalAccessTokenResult)
		resp, err := l.impl.ListPersonalAccessToken(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &authn.AuthNServiceListPersonalAccessTokenArgs{Req: req}
	result := &authn.AuthNServiceListPersonalAccessTokenResult{}
	ctx = l.injectRPCInfo(ctx, "ListPersonalAccessToken")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

// VerifyToken
// 验证token是否有效
func (l *LocalAuthNService) VerifyToken(ctx context.Context, req *authn.VerifyTokenRequest, callOptions ...callopt.Option) (*authn.VerifyTokenResponse, error) {
	chain := l.mds(func(ctx context.Context, in, out interface{}) error {
		arg := in.(*authn.AuthNServiceVerifyTokenArgs)
		result := out.(*authn.AuthNServiceVerifyTokenResult)
		resp, err := l.impl.VerifyToken(ctx, arg.Req)
		if err != nil {
			return err
		}
		result.SetSuccess(resp)
		return nil
	})

	arg := &authn.AuthNServiceVerifyTokenArgs{Req: req}
	result := &authn.AuthNServiceVerifyTokenResult{}
	ctx = l.injectRPCInfo(ctx, "VerifyToken")
	if err := chain(ctx, arg, result); err != nil {
		return nil, err
	}
	return result.GetSuccess(), nil
}

func (l *LocalAuthNService) injectRPCInfo(ctx context.Context, method string) context.Context {
	rpcStats := rpcinfo.AsMutableRPCStats(rpcinfo.NewRPCStats())
	ri := rpcinfo.NewRPCInfo(
		rpcinfo.NewEndpointInfo("AuthNService", method, nil, nil),
		rpcinfo.NewEndpointInfo("AuthNService", method, nil, nil),
		rpcinfo.NewServerInvocation(),
		nil,
		rpcStats.ImmutableView(),
	)
	return rpcinfo.NewCtxWithRPCInfo(ctx, ri)
}
